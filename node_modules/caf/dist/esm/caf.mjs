/*! CAF: caf.mjs
	v14.0.0 (c) 2021 Kyle Simpson
	MIT License: http://getify.mit-license.org
*/
import{CLEANUP_FN,TIMEOUT_TOKEN,cancelToken,signalPromise,processTokenOrSignal}from"./shared.mjs";export default Object.assign(CAF,{cancelToken:cancelToken,delay:delay,timeout:timeout,signalRace:signalRace,signalAll:signalAll,tokenCycle:tokenCycle});export{cancelToken};export{delay};export{timeout};export{signalRace};export{signalAll};export{tokenCycle};function CAF(n){return function instance(e,...r){var l,a;if(({tokenOrSignal:e,signal:l,signalPr:a}=processTokenOrSignal(e)),l.aborted)return a;var o=a.catch((function onCancellation(n){try{var e=u.return();throw void 0!==e.value?e.value:n}finally{u=i=o=s=null}})),{it:u,result:i}=runner.call(this,n,l,...r),s=Promise.race([i,o]);if(e!==l&&e[TIMEOUT_TOKEN]){let n=function cancelTimer(){e.abort(),e=n=null};s.then(n,n)}else s.catch((()=>{})),e=null;return l=r=null,s}}function delay(n,e){var r,l;return"number"==typeof n&&"number"!=typeof e&&([e,n]=[n,e]),n&&({tokenOrSignal:n,signal:r,signalPr:l}=processTokenOrSignal(n)),r&&r.aborted?l:new Promise((function c(n,a){r&&(l.catch((function onAbort(l){o&&(clearTimeout(o),a(l||`delay (${e}) interrupted`)),n=a=o=r=null})),l=null);var o=setTimeout((function onTimeout(){n(`delayed: ${e}`),n=a=o=r=null}),e)}))}function timeout(n,e="Timeout"){n=Number(n)||0;var r=new cancelToken;return delay(r.signal,n).then(cleanup,cleanup),Object.defineProperty(r,TIMEOUT_TOKEN,{value:!0,writable:!1,enumerable:!1,configurable:!1}),r;function cleanup(){r.abort(e),r=null}}function splitSignalPRs(n){return n.reduce((function split(n,e){var r=signalPromise(e);return n[0].push(r),e.pr||n[1].push(r),n}),[[],[]])}function triggerAndCleanup(n,e,r){n.then((function t(n){e.abort(n),e=null})).then((function t(){for(let n of r)n[CLEANUP_FN]&&n[CLEANUP_FN]();r=null}))}function prCatch(n){return n.catch((n=>n))}function signalRace(n){var e=new cancelToken,[r,l]=splitSignalPRs(n);return triggerAndCleanup(prCatch(Promise.race(r)),e,l),e.signal}function signalAll(n){var e=new cancelToken,[r,l]=splitSignalPRs(n);return triggerAndCleanup(Promise.all(r.map(prCatch)),e,l),e.signal}function tokenCycle(){var n;return function getNextToken(e){return n&&(n.abort(e),n.discard()),n=new cancelToken}}function runner(n,...e){var r=n.apply(this,e);return n=e=null,{it:r,result:function getNextResult(n){try{var e=r.next(n);n=null}catch(n){return Promise.reject(n)}return function processResult(n){var e=Promise.resolve(n.value);return n.done?r=null:(e=e.then(getNextResult,(function onRejection(n){return Promise.resolve(r.throw(n)).then(processResult)}))).catch((function cleanup(){r=null})),n=null,e}(e)}()}}